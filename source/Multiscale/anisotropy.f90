!> This module parses the anisotropy fields and allows to find
!!  to which anisotropy region a point belongs.
!! The anisotropy is not modified in any way, it is not
!!  required for the multiscale method to work, but it is convenient
!!  to create anisotropy files this way, as the user does not know how
!!  the indices of the atoms will correspond to the positions of the
!!  setup generated by the tool.
!> @authors
!> Edgar Mendez
!> Nikos  Ntallis
!> Manuel Pereiro


module Anisotropy
  use Parameters
  use MultiscaleFileParser
  use FileInput
  use ShapeModule

  implicit none

  !> Number of axis supported in UppASD
  integer, parameter :: MAX_ANISOTROPY_AXES = 2

  !> Anisotropy types
  integer, parameter :: ANISOTROPY_TYPE_UNIAXIAL = 1
  integer, parameter :: ANISOTROPY_TYPE_CUBIC    = 2
  integer, parameter :: ANISOTROPY_TYPE_BOTH     = 7

  !> Parameters for one anisotropy axis
  type AnisotropyParameters
     integer :: type !> One of ANISOTROPY_TYPE_*
     real(dblprec) :: ratio !> if type = ANISOTROPY_TYPE_BOTH, ratio between uniaxial and cubic
     real(dblprec) :: K1
     real(dblprec) :: K2
     real(dblprec), dimension(3) :: e
  end type AnisotropyParameters

  !> Single-linked null-ended list of anisotropy descriptors.
  !! Holds the anisotropy parameters and the zone where it applies
  !! Empty lists are represented by a nullified pointer
  type AnisotropyList
     type(ShapeList)  :: shapes

     !> UppASD supports multiple-axis anisotropy with up to two axes.
     !! Here we hold how many axes are used and their parameters
     integer :: axes 
     type(AnisotropyParameters),dimension(MAX_ANISOTROPY_AXES) :: parameters
     
     type(AnisotropyList), pointer :: next
  end type AnisotropyList
    
  private

  public &
       AnisotropyList, parseAnisotropyList,  &
       deallocateAnisotropyList, anisotropyFromPoint, countAnisotropyAxes
  
  
contains
  
  !> Creates a new Anisotropy list with one element.
  !! Use concatAnisotropyLists with this function to make arbitrary lists.
  subroutine newAnisotropyList(list)
    implicit none
    type(AnisotropyList), pointer, intent(out) :: list
    integer :: i
    allocate(list)
    nullify(list%next)
    call allocateShapeList(list % shapes)
    list%axes = 1
    do i = 1, MAX_ANISOTROPY_AXES
       list%parameters(i)%ratio = 0d0 
       list%parameters(i)%type = ANISOTROPY_TYPE_UNIAXIAL
       list%parameters(i)%K1 = 0d0
       list%parameters(i)%K2 = 0d0
       list%parameters(i)%e = 0d0
    end do
  end subroutine newAnisotropyList

  !> Concatenates two anisotropy lists.
  !! Never deallocate l2, it will be deallocated with the result.
  !! The result is left in l1
  subroutine concatAnisotropyLists(l1,l2)
    implicit none
    type(AnisotropyList), pointer, intent(in) :: l1
    type(AnisotropyList), pointer, intent(in) :: l2

    type(AnisotropyList), pointer :: last_l1
    
    last_l1 => l1
    do while (associated(last_l1%next))
       last_l1=>last_l1%next
    end do

    last_l1%next => l2
  end subroutine concatAnisotropyLists

  !> Counts how many anisotropy axis are used at most in the anisotropy list
  integer function countAnisotropyaxes(ani)
    implicit none
    type(AnisotropyList), pointer, intent(in) ::ani
    
    type(AnisotropyList), pointer :: p
    integer :: count

    count = 0
    p=>ani
    do while (associated(p))
       if (p%axes > count) then
          count = p%axes
       end if
       p => p%next
    end do
    countAnisotropyaxes = count
  end function countAnisotropyaxes
  
  !> Deallocate an anisotropy list (the whole chain from the given element).
  !! Shapes inside each element are also freed
  !! The pointer is nullified.
  subroutine deallocateAnisotropyList(list)
    implicit none
    type(AnisotropyList), pointer, intent(inout) :: list
    type(AnisotropyList), pointer :: cur
    type(AnisotropyList), pointer :: next

    cur => list 
    do while (associated(cur))       
       next => cur%next
       call deallocateShapeList(cur%shapes)
       deallocate(cur)
       cur => next
    end do
    nullify(list)

  end subroutine deallocateAnisotropyList

  !> Given a point and an anisotropy list, returns a pointer to the
  !! first element in the list that covers the point.
  !! If no element in the list covers the point, a null pointer is
  !! returned instead.
  function anisotropyFromPoint(point,aniso) result (p)
    implicit none
    real(dblprec), dimension(3), intent(in)   :: point
    type(AnisotropyList), intent(in), pointer :: aniso
    type(AnisotropyList), pointer :: p

    p => aniso
    do while (associated(p))
       if(isPointInsideShapeList(p%shapes, point)) return
       p => p%next       
    end do
  end function anisotropyFromPoint


  !> Reads anisotropy parameters from a fileData
  subroutine parseAnisotropyParameters(fData, parameters)
    use FileInput
  implicit none
    type(FileData), intent(inout) :: fData
    type(AnisotropyParameters), intent(out) :: parameters

    integer :: i
    
    ! Parse anisotropy type
    if (fData%word == "uniaxial") then
       parameters%type = ANISOTROPY_TYPE_UNIAXIAL
    else if (fData%word == "cubic") then
       parameters%type = ANISOTROPY_TYPE_CUBIC
    else if (fData%word == "both") then
       parameters%type = ANISOTROPY_TYPE_BOTH
       call readNextWord(fData)
       call parseReal(fData,parameters%ratio)
       if (fData%ierr /= 0) then
          call createErrorMsg(fData, 1, '"both" should be followed by the ratio'//&
               ' between Uniaxial and Cubic.')
          return
       end if
    else
       call createErrorMsg(fData, 1, 'Expected anisotropy type ' // & 
            '(either "uniaxial", "cubic" or "both").')
       return
    end if

    call readNextWord(fData) 

    ! Parse K1, K2 and e
    call parseReal(fData,parameters%K1)
    if (fData%ierr /= 0) return
    call readNextWord(fData)

    call skipOptionalDelimiter(fData)

    call parseReal(fData,parameters%K2)
    if (fData%ierr /= 0) return
    call readNextWord(fData)

    call skipOptionalDelimiter(fData)

    do i=1,3
       call parseReal(fData,parameters%e(i))
       if (fData%ierr /= 0) then
          call createErrorMsg(fData,1, 'Unexpected symbol or end of line '//&
               'when reading anisotropy vector.')
          return
       end if
       call readNextWord(fData)
    end do
    parameters%e = &
         parameters%e / sqrt(sum(parameters%e**2))

  end subroutine parseAnisotropyParameters


     
  !> Parses an anisotropy list from a FileData.
  subroutine parseAnisotropyList(fData, aniso)
    use FileInput
  implicit none
    type(FileData), intent(inout) :: fData
    type(AnisotropyList), intent(out), pointer :: aniso
    

    type(AnisotropyList), pointer :: new_aniso
    call newAnisotropyList(new_aniso)

    new_aniso%axes = 0
    do while (.not. isAtEndOfLine(fData) .and. fData%word /= "file" .and. &
         new_aniso%axes < MAX_ANISOTROPY_AXES)       
       new_aniso%axes = new_aniso%axes + 1 
       call parseAnisotropyParameters(fData, new_aniso%parameters(new_aniso%axes))
       call skipOptionalDelimiter(fData)
    end do

    if(new_aniso%axes >= MAX_ANISOTROPY_AXES) then
       print *, "WARNING: Too many axes specified in anisotropy."
       print *, "  Currently the number of supported axes is ", MAX_ANISOTROPY_AXES
       print *, "  Additional axes are ignored."
       new_aniso%axes = MAX_ANISOTROPY_AXES
    end if

    
    if(new_aniso%axes == 0) then
       call createErrorMsg(fData,1, 'Expected anisotropy parameters')
       return
    end if

        
    if (fData%ierr /= 0) then
       call deallocateAnisotropyList(new_aniso)
       return
    end if

    call parseShapeList(fData, new_aniso%shapes)
    if (associated(aniso)) then
       call concatAnisotropyLists(aniso, new_aniso)
    else
       aniso => new_aniso
    end if
    
  end subroutine parseAnisotropyList


end module Anisotropy
